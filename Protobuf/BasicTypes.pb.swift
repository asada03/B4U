// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: BasicTypes.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Proto_HederaFunctionality: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case cryptoCreate // = 0
  case cryptoTransfer // = 1
  case cryptoUpdate // = 2
  case cryptoDelete // = 3
  case cryptoAddClaim // = 4
  case cryptoDeletClaim // = 5
  case contractCall // = 6
  case contractCreate // = 7
  case contractUpdate // = 8
  case fileCreate // = 9
  case fileAppend // = 10
  case fileUpdate // = 11
  case fileDelete // = 12
  case cryptoGetAccountBalance // = 13
  case cryptoGetAccountRecords // = 14
  case cryptoGetInfo // = 15
  case contractCallLocal // = 16
  case contractGetInfo // = 17
  case contractGetBytecode // = 18
  case getBySolidityID // = 19
  case getByKey // = 20
  case cryptoGetClaim // = 21
  case cryptoGetStakers // = 22
  case fileGetContents // = 23
  case fileGetInfo // = 24
  case transactionGetRecord // = 25
  case UNRECOGNIZED(Int)

  init() {
    self = .cryptoCreate
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cryptoCreate
    case 1: self = .cryptoTransfer
    case 2: self = .cryptoUpdate
    case 3: self = .cryptoDelete
    case 4: self = .cryptoAddClaim
    case 5: self = .cryptoDeletClaim
    case 6: self = .contractCall
    case 7: self = .contractCreate
    case 8: self = .contractUpdate
    case 9: self = .fileCreate
    case 10: self = .fileAppend
    case 11: self = .fileUpdate
    case 12: self = .fileDelete
    case 13: self = .cryptoGetAccountBalance
    case 14: self = .cryptoGetAccountRecords
    case 15: self = .cryptoGetInfo
    case 16: self = .contractCallLocal
    case 17: self = .contractGetInfo
    case 18: self = .contractGetBytecode
    case 19: self = .getBySolidityID
    case 20: self = .getByKey
    case 21: self = .cryptoGetClaim
    case 22: self = .cryptoGetStakers
    case 23: self = .fileGetContents
    case 24: self = .fileGetInfo
    case 25: self = .transactionGetRecord
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cryptoCreate: return 0
    case .cryptoTransfer: return 1
    case .cryptoUpdate: return 2
    case .cryptoDelete: return 3
    case .cryptoAddClaim: return 4
    case .cryptoDeletClaim: return 5
    case .contractCall: return 6
    case .contractCreate: return 7
    case .contractUpdate: return 8
    case .fileCreate: return 9
    case .fileAppend: return 10
    case .fileUpdate: return 11
    case .fileDelete: return 12
    case .cryptoGetAccountBalance: return 13
    case .cryptoGetAccountRecords: return 14
    case .cryptoGetInfo: return 15
    case .contractCallLocal: return 16
    case .contractGetInfo: return 17
    case .contractGetBytecode: return 18
    case .getBySolidityID: return 19
    case .getByKey: return 20
    case .cryptoGetClaim: return 21
    case .cryptoGetStakers: return 22
    case .fileGetContents: return 23
    case .fileGetInfo: return 24
    case .transactionGetRecord: return 25
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_HederaFunctionality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_HederaFunctionality] = [
    .cryptoCreate,
    .cryptoTransfer,
    .cryptoUpdate,
    .cryptoDelete,
    .cryptoAddClaim,
    .cryptoDeletClaim,
    .contractCall,
    .contractCreate,
    .contractUpdate,
    .fileCreate,
    .fileAppend,
    .fileUpdate,
    .fileDelete,
    .cryptoGetAccountBalance,
    .cryptoGetAccountRecords,
    .cryptoGetInfo,
    .contractCallLocal,
    .contractGetInfo,
    .contractGetBytecode,
    .getBySolidityID,
    .getByKey,
    .cryptoGetClaim,
    .cryptoGetStakers,
    .fileGetContents,
    .fileGetInfo,
    .transactionGetRecord,
  ]
}

#endif  // swift(>=4.2)

/// Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
///
///Everything is partitioned into realms so that each Solidity smart contract can  access everything in just a single realm, locking all those entities while it's  running, but other smart contracts could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized somewhat, even though the  language itself assumes everything is serial. 
struct Proto_ShardID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the shard number (nonnegative)
  var shardNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. 
struct Proto_RealmID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the shard number (nonnegative)
  var shardNum: Int64 = 0

  ///the realm number (nonnegative)
  var realmNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for an a cryptocurrency account  
struct Proto_AccountID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the shard number (nonnegative)
  var shardNum: Int64 = 0

  ///the realm number (nonnegative)
  var realmNum: Int64 = 0

  ///a nonnegative number unique within its realm
  var accountNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a file  
struct Proto_FileID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the shard number (nonnegative)
  var shardNum: Int64 = 0

  ///the realm number (nonnegative)
  var realmNum: Int64 = 0

  ///a nonnegative number unique within its realm
  var fileNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a smart contract instance  
struct Proto_ContractID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the shard number (nonnegative)
  var shardNum: Int64 = 0

  ///the realm number (nonnegative)
  var realmNum: Int64 = 0

  ///a nonnegative number unique within its realm
  var contractNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. 
struct Proto_TransactionID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the account that paid for this transaction
  var accountID: Proto_AccountID {
    get {return _storage._accountID ?? Proto_AccountID()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  /// the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
  var transactionValidStart: Proto_Timestamp {
    get {return _storage._transactionValidStart ?? Proto_Timestamp()}
    set {_uniqueStorage()._transactionValidStart = newValue}
  }
  /// Returns true if `transactionValidStart` has been explicitly set.
  var hasTransactionValidStart: Bool {return _storage._transactionValidStart != nil}
  /// Clears the value of `transactionValidStart`. Subsequent reads from it will return its default value.
  mutating func clearTransactionValidStart() {_uniqueStorage()._transactionValidStart = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.
///
/// A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.
///
/// A key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.
///
/// A Key can be a list of keys. Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key.
///
/// A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. The current API only allows the nesting to a depth of 3 levels, such as the key being a list of threshold keys, each of which contains a list of primitive keys (e.g., ed25519). In the future, this requirement may be relaxed, to allow deeper nesting.
struct Proto_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: OneOf_Key? {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// smart contract instance that is authorized as if it had signed with a key
  var contractID: Proto_ContractID {
    get {
      if case .contractID(let v)? = _storage._key {return v}
      return Proto_ContractID()
    }
    set {_uniqueStorage()._key = .contractID(newValue)}
  }

  /// ed25519 public key
  var ed25519: Data {
    get {
      if case .ed25519(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .ed25519(newValue)}
  }

  ///RSA-3072 public key
  var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .rsa3072(newValue)}
  }

  ///ECDSA with the p-384 curve public key
  var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .ecdsa384(newValue)}
  }

  /// a threshold N followed by a list of M keys, any N of which are required to form a valid signature
  var thresholdKey: Proto_ThresholdKey {
    get {
      if case .thresholdKey(let v)? = _storage._key {return v}
      return Proto_ThresholdKey()
    }
    set {_uniqueStorage()._key = .thresholdKey(newValue)}
  }

  /// a list of Keys.
  var keyList: Proto_KeyList {
    get {
      if case .keyList(let v)? = _storage._key {return v}
      return Proto_KeyList()
    }
    set {_uniqueStorage()._key = .keyList(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Key: Equatable {
    /// smart contract instance that is authorized as if it had signed with a key
    case contractID(Proto_ContractID)
    /// ed25519 public key
    case ed25519(Data)
    ///RSA-3072 public key
    case rsa3072(Data)
    ///ECDSA with the p-384 curve public key
    case ecdsa384(Data)
    /// a threshold N followed by a list of M keys, any N of which are required to form a valid signature
    case thresholdKey(Proto_ThresholdKey)
    /// a list of Keys.
    case keyList(Proto_KeyList)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Key.OneOf_Key, rhs: Proto_Key.OneOf_Key) -> Bool {
      switch (lhs, rhs) {
      case (.contractID(let l), .contractID(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      case (.thresholdKey(let l), .thresholdKey(let r)): return l == r
      case (.keyList(let l), .keyList(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. 
struct Proto_ThresholdKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// a valid signature set must have at least this many signatures
  var threshold: UInt32 {
    get {return _storage._threshold}
    set {_uniqueStorage()._threshold = newValue}
  }

  /// list of all the keys that can sign
  var keys: Proto_KeyList {
    get {return _storage._keys ?? Proto_KeyList()}
    set {_uniqueStorage()._keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  var hasKeys: Bool {return _storage._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  mutating func clearKeys() {_uniqueStorage()._keys = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of keys 
struct Proto_KeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list of keys
  var keys: [Proto_Key] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.
///
/// The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.
struct Proto_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signature: OneOf_Signature? {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  /// smart contract virtual signature (always length zero)
  var contract: Data {
    get {
      if case .contract(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .contract(newValue)}
  }

  /// ed25519 signature
  var ed25519: Data {
    get {
      if case .ed25519(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .ed25519(newValue)}
  }

  ///RSA-3072 signature
  var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .rsa3072(newValue)}
  }

  ///ECDSA p-384 signature
  var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .ecdsa384(newValue)}
  }

  /// a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
  var thresholdSignature: Proto_ThresholdSignature {
    get {
      if case .thresholdSignature(let v)? = _storage._signature {return v}
      return Proto_ThresholdSignature()
    }
    set {_uniqueStorage()._signature = .thresholdSignature(newValue)}
  }

  /// a list of M signatures, each corresponding to a Key in a KeyList of the same length.
  var signatureList: Proto_SignatureList {
    get {
      if case .signatureList(let v)? = _storage._signature {return v}
      return Proto_SignatureList()
    }
    set {_uniqueStorage()._signature = .signatureList(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Signature: Equatable {
    /// smart contract virtual signature (always length zero)
    case contract(Data)
    /// ed25519 signature
    case ed25519(Data)
    ///RSA-3072 signature
    case rsa3072(Data)
    ///ECDSA p-384 signature
    case ecdsa384(Data)
    /// a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
    case thresholdSignature(Proto_ThresholdSignature)
    /// a list of M signatures, each corresponding to a Key in a KeyList of the same length.
    case signatureList(Proto_SignatureList)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Signature.OneOf_Signature, rhs: Proto_Signature.OneOf_Signature) -> Bool {
      switch (lhs, rhs) {
      case (.contract(let l), .contract(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      case (.thresholdSignature(let l), .thresholdSignature(let r)): return l == r
      case (.signatureList(let l), .signatureList(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. 
struct Proto_ThresholdSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null
  var sigs: Proto_SignatureList {
    get {return _storage._sigs ?? Proto_SignatureList()}
    set {_uniqueStorage()._sigs = newValue}
  }
  /// Returns true if `sigs` has been explicitly set.
  var hasSigs: Bool {return _storage._sigs != nil}
  /// Clears the value of `sigs`. Subsequent reads from it will return its default value.
  mutating func clearSigs() {_uniqueStorage()._sigs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The signatures corresponding to a KeyList of the same length  
struct Proto_SignatureList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// each signature corresponds to a Key in the KeyList
  var sigs: [Proto_Signature] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_FeeComponents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var min: Int64 = 0

  var max: Int64 = 0

  var constant: Int64 = 0

  var bpt: Int64 = 0

  var vpt: Int64 = 0

  var rbs: Int64 = 0

  var sbs: Int64 = 0

  var gas: Int64 = 0

  var tv: Int64 = 0

  var bpr: Int64 = 0

  var sbpr: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_TransactionFeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specific Transaction or Query
  var hederaFunctionality: Proto_HederaFunctionality {
    get {return _storage._hederaFunctionality}
    set {_uniqueStorage()._hederaFunctionality = newValue}
  }

  var feeData: Proto_FeeData {
    get {return _storage._feeData ?? Proto_FeeData()}
    set {_uniqueStorage()._feeData = newValue}
  }
  /// Returns true if `feeData` has been explicitly set.
  var hasFeeData: Bool {return _storage._feeData != nil}
  /// Clears the value of `feeData`. Subsequent reads from it will return its default value.
  mutating func clearFeeData() {_uniqueStorage()._feeData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_FeeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fee charged by Node for this functionality
  var nodedata: Proto_FeeComponents {
    get {return _storage._nodedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._nodedata = newValue}
  }
  /// Returns true if `nodedata` has been explicitly set.
  var hasNodedata: Bool {return _storage._nodedata != nil}
  /// Clears the value of `nodedata`. Subsequent reads from it will return its default value.
  mutating func clearNodedata() {_uniqueStorage()._nodedata = nil}

  /// Fee charged for network operations by Hedera
  var networkdata: Proto_FeeComponents {
    get {return _storage._networkdata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._networkdata = newValue}
  }
  /// Returns true if `networkdata` has been explicitly set.
  var hasNetworkdata: Bool {return _storage._networkdata != nil}
  /// Clears the value of `networkdata`. Subsequent reads from it will return its default value.
  mutating func clearNetworkdata() {_uniqueStorage()._networkdata = nil}

  /// Fee charged for provding service by Hedera
  var servicedata: Proto_FeeComponents {
    get {return _storage._servicedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._servicedata = newValue}
  }
  /// Returns true if `servicedata` has been explicitly set.
  var hasServicedata: Bool {return _storage._servicedata != nil}
  /// Clears the value of `servicedata`. Subsequent reads from it will return its default value.
  mutating func clearServicedata() {_uniqueStorage()._servicedata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_FeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionFeeSchedule: [Proto_TransactionFeeSchedule] {
    get {return _storage._transactionFeeSchedule}
    set {_uniqueStorage()._transactionFeeSchedule = newValue}
  }

  var feeScheduleValidityDuration: Proto_Duration {
    get {return _storage._feeScheduleValidityDuration ?? Proto_Duration()}
    set {_uniqueStorage()._feeScheduleValidityDuration = newValue}
  }
  /// Returns true if `feeScheduleValidityDuration` has been explicitly set.
  var hasFeeScheduleValidityDuration: Bool {return _storage._feeScheduleValidityDuration != nil}
  /// Clears the value of `feeScheduleValidityDuration`. Subsequent reads from it will return its default value.
  mutating func clearFeeScheduleValidityDuration() {_uniqueStorage()._feeScheduleValidityDuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ipAddress: Data = SwiftProtobuf.Internal.emptyData

  var portno: Int32 = 0

  var memo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_NodeAddressBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeAddress: [Proto_NodeAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_HederaFunctionality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CryptoCreate"),
    1: .same(proto: "CryptoTransfer"),
    2: .same(proto: "CryptoUpdate"),
    3: .same(proto: "CryptoDelete"),
    4: .same(proto: "CryptoAddClaim"),
    5: .same(proto: "CryptoDeletClaim"),
    6: .same(proto: "ContractCall"),
    7: .same(proto: "ContractCreate"),
    8: .same(proto: "ContractUpdate"),
    9: .same(proto: "FileCreate"),
    10: .same(proto: "FileAppend"),
    11: .same(proto: "FileUpdate"),
    12: .same(proto: "FileDelete"),
    13: .same(proto: "CryptoGetAccountBalance"),
    14: .same(proto: "CryptoGetAccountRecords"),
    15: .same(proto: "CryptoGetInfo"),
    16: .same(proto: "ContractCallLocal"),
    17: .same(proto: "ContractGetInfo"),
    18: .same(proto: "ContractGetBytecode"),
    19: .same(proto: "GetBySolidityID"),
    20: .same(proto: "GetByKey"),
    21: .same(proto: "CryptoGetClaim"),
    22: .same(proto: "CryptoGetStakers"),
    23: .same(proto: "FileGetContents"),
    24: .same(proto: "FileGetInfo"),
    25: .same(proto: "TransactionGetRecord"),
  ]
}

extension Proto_ShardID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_ShardID) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".ShardID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ShardID, rhs: Proto_ShardID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RealmID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_RealmID) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".RealmID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RealmID, rhs: Proto_RealmID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_AccountID) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".AccountID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "accountNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.accountNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.accountNum != 0 {
      try visitor.visitSingularInt64Field(value: self.accountNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AccountID, rhs: Proto_AccountID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.accountNum != rhs.accountNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FileID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_FileID) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".FileID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "fileNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.fileNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.fileNum != 0 {
      try visitor.visitSingularInt64Field(value: self.fileNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FileID, rhs: Proto_FileID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.fileNum != rhs.fileNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_ContractID) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".ContractID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "contractNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.contractNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.contractNum != 0 {
      try visitor.visitSingularInt64Field(value: self.contractNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContractID, rhs: Proto_ContractID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.contractNum != rhs.contractNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_TransactionID) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".TransactionID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "accountID"),
    1: .same(proto: "transactionValidStart"),
  ]

  fileprivate class _StorageClass {
    var _accountID: Proto_AccountID? = nil
    var _transactionValidStart: Proto_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _transactionValidStart = source._transactionValidStart
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transactionValidStart)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._accountID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transactionValidStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TransactionID, rhs: Proto_TransactionID) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._transactionValidStart != rhs_storage._transactionValidStart {return false}
        return true
      }
      if !storagesAreEqual {return false}
        
        func _protobuf_generated_isEqualTo(other: Proto_Key) -> Bool {
            return false
        }
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_Key) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".Key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdKey"),
    6: .same(proto: "keyList"),
  ]

  fileprivate class _StorageClass {
    var _key: Proto_Key.OneOf_Key?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Proto_ContractID?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .contractID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .contractID(v)}
        case 2:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .ed25519(v)}
        case 3:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .rsa3072(v)}
        case 4:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .ecdsa384(v)}
        case 5:
          var v: Proto_ThresholdKey?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .thresholdKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .thresholdKey(v)}
        case 6:
          var v: Proto_KeyList?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .keyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .keyList(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._key {
      case .contractID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .ed25519(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case .rsa3072(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      case .ecdsa384(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      case .thresholdKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .keyList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Key, rhs: Proto_Key) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_ThresholdKey) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".ThresholdKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "keys"),
  ]

  fileprivate class _StorageClass {
    var _threshold: UInt32 = 0
    var _keys: Proto_KeyList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _threshold = source._threshold
      _keys = source._keys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._threshold)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._keys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._threshold != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._threshold, fieldNumber: 1)
      }
      if let v = _storage._keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ThresholdKey, rhs: Proto_ThresholdKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._threshold != rhs_storage._threshold {return false}
        if _storage._keys != rhs_storage._keys {return false}
        return true
      }
      if !storagesAreEqual {return false}
        
        func _protobuf_generated_isEqualTo(other: Proto_KeyList) -> Bool {
            return false
        }
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_KeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_KeyList) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".KeyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_KeyList, rhs: Proto_KeyList) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_Signature) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".Signature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contract"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdSignature"),
    6: .same(proto: "signatureList"),
  ]

  fileprivate class _StorageClass {
    var _signature: Proto_Signature.OneOf_Signature?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .contract(v)}
        case 2:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .ed25519(v)}
        case 3:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .rsa3072(v)}
        case 4:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .ecdsa384(v)}
        case 5:
          var v: Proto_ThresholdSignature?
          if let current = _storage._signature {
            try decoder.handleConflictingOneOf()
            if case .thresholdSignature(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._signature = .thresholdSignature(v)}
        case 6:
          var v: Proto_SignatureList?
          if let current = _storage._signature {
            try decoder.handleConflictingOneOf()
            if case .signatureList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._signature = .signatureList(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._signature {
      case .contract(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      case .ed25519(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case .rsa3072(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      case .ecdsa384(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      case .thresholdSignature(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .signatureList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Signature, rhs: Proto_Signature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_ThresholdSignature) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".ThresholdSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  fileprivate class _StorageClass {
    var _sigs: Proto_SignatureList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sigs = source._sigs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sigs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sigs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ThresholdSignature, rhs: Proto_ThresholdSignature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sigs != rhs_storage._sigs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_SignatureList) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".SignatureList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.sigs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SignatureList, rhs: Proto_SignatureList) -> Bool {
    if lhs.sigs != rhs.sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_FeeComponents) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".FeeComponents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "constant"),
    4: .same(proto: "bpt"),
    5: .same(proto: "vpt"),
    6: .same(proto: "rbs"),
    7: .same(proto: "sbs"),
    8: .same(proto: "gas"),
    9: .same(proto: "tv"),
    10: .same(proto: "bpr"),
    11: .same(proto: "sbpr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.min)
      case 2: try decoder.decodeSingularInt64Field(value: &self.max)
      case 3: try decoder.decodeSingularInt64Field(value: &self.constant)
      case 4: try decoder.decodeSingularInt64Field(value: &self.bpt)
      case 5: try decoder.decodeSingularInt64Field(value: &self.vpt)
      case 6: try decoder.decodeSingularInt64Field(value: &self.rbs)
      case 7: try decoder.decodeSingularInt64Field(value: &self.sbs)
      case 8: try decoder.decodeSingularInt64Field(value: &self.gas)
      case 9: try decoder.decodeSingularInt64Field(value: &self.tv)
      case 10: try decoder.decodeSingularInt64Field(value: &self.bpr)
      case 11: try decoder.decodeSingularInt64Field(value: &self.sbpr)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularInt64Field(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularInt64Field(value: self.max, fieldNumber: 2)
    }
    if self.constant != 0 {
      try visitor.visitSingularInt64Field(value: self.constant, fieldNumber: 3)
    }
    if self.bpt != 0 {
      try visitor.visitSingularInt64Field(value: self.bpt, fieldNumber: 4)
    }
    if self.vpt != 0 {
      try visitor.visitSingularInt64Field(value: self.vpt, fieldNumber: 5)
    }
    if self.rbs != 0 {
      try visitor.visitSingularInt64Field(value: self.rbs, fieldNumber: 6)
    }
    if self.sbs != 0 {
      try visitor.visitSingularInt64Field(value: self.sbs, fieldNumber: 7)
    }
    if self.gas != 0 {
      try visitor.visitSingularInt64Field(value: self.gas, fieldNumber: 8)
    }
    if self.tv != 0 {
      try visitor.visitSingularInt64Field(value: self.tv, fieldNumber: 9)
    }
    if self.bpr != 0 {
      try visitor.visitSingularInt64Field(value: self.bpr, fieldNumber: 10)
    }
    if self.sbpr != 0 {
      try visitor.visitSingularInt64Field(value: self.sbpr, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FeeComponents, rhs: Proto_FeeComponents) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.constant != rhs.constant {return false}
    if lhs.bpt != rhs.bpt {return false}
    if lhs.vpt != rhs.vpt {return false}
    if lhs.rbs != rhs.rbs {return false}
    if lhs.sbs != rhs.sbs {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.tv != rhs.tv {return false}
    if lhs.bpr != rhs.bpr {return false}
    if lhs.sbpr != rhs.sbpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_TransactionFeeSchedule) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".TransactionFeeSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hederaFunctionality"),
    2: .same(proto: "feeData"),
  ]

  fileprivate class _StorageClass {
    var _hederaFunctionality: Proto_HederaFunctionality = .cryptoCreate
    var _feeData: Proto_FeeData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hederaFunctionality = source._hederaFunctionality
      _feeData = source._feeData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._hederaFunctionality)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._feeData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._hederaFunctionality != .cryptoCreate {
        try visitor.visitSingularEnumField(value: _storage._hederaFunctionality, fieldNumber: 1)
      }
      if let v = _storage._feeData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TransactionFeeSchedule, rhs: Proto_TransactionFeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hederaFunctionality != rhs_storage._hederaFunctionality {return false}
        if _storage._feeData != rhs_storage._feeData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_FeeData) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".FeeData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodedata"),
    2: .same(proto: "networkdata"),
    3: .same(proto: "servicedata"),
  ]

  fileprivate class _StorageClass {
    var _nodedata: Proto_FeeComponents? = nil
    var _networkdata: Proto_FeeComponents? = nil
    var _servicedata: Proto_FeeComponents? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodedata = source._nodedata
      _networkdata = source._networkdata
      _servicedata = source._servicedata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._nodedata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._networkdata)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._servicedata)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._nodedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._networkdata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._servicedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FeeData, rhs: Proto_FeeData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodedata != rhs_storage._nodedata {return false}
        if _storage._networkdata != rhs_storage._networkdata {return false}
        if _storage._servicedata != rhs_storage._servicedata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_FeeSchedule) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".FeeSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionFeeSchedule"),
    2: .same(proto: "feeScheduleValidityDuration"),
  ]

  fileprivate class _StorageClass {
    var _transactionFeeSchedule: [Proto_TransactionFeeSchedule] = []
    var _feeScheduleValidityDuration: Proto_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionFeeSchedule = source._transactionFeeSchedule
      _feeScheduleValidityDuration = source._feeScheduleValidityDuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._transactionFeeSchedule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._feeScheduleValidityDuration)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactionFeeSchedule.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactionFeeSchedule, fieldNumber: 1)
      }
      if let v = _storage._feeScheduleValidityDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FeeSchedule, rhs: Proto_FeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionFeeSchedule != rhs_storage._transactionFeeSchedule {return false}
        if _storage._feeScheduleValidityDuration != rhs_storage._feeScheduleValidityDuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_NodeAddress) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipAddress"),
    2: .same(proto: "portno"),
    3: .same(proto: "memo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ipAddress)
      case 2: try decoder.decodeSingularInt32Field(value: &self.portno)
      case 3: try decoder.decodeSingularBytesField(value: &self.memo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ipAddress, fieldNumber: 1)
    }
    if self.portno != 0 {
      try visitor.visitSingularInt32Field(value: self.portno, fieldNumber: 2)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularBytesField(value: self.memo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_NodeAddress, rhs: Proto_NodeAddress) -> Bool {
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.portno != rhs.portno {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddressBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_NodeAddressBook) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".NodeAddressBook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodeAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeAddress.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_NodeAddressBook, rhs: Proto_NodeAddressBook) -> Bool {
    if lhs.nodeAddress != rhs.nodeAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
