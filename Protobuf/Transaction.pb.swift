// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Transaction.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A single transaction. All transaction types are possible here. 
struct Proto_TransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect
  var transactionID: Proto_TransactionID {
    get {return _storage._transactionID ?? Proto_TransactionID()}
    set {_uniqueStorage()._transactionID = newValue}
  }
  /// Returns true if `transactionID` has been explicitly set.
  var hasTransactionID: Bool {return _storage._transactionID != nil}
  /// Clears the value of `transactionID`. Subsequent reads from it will return its default value.
  mutating func clearTransactionID() {_uniqueStorage()._transactionID = nil}

  /// the account of the node that submits the client's transaction to the network
  var nodeAccountID: Proto_AccountID {
    get {return _storage._nodeAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._nodeAccountID = newValue}
  }
  /// Returns true if `nodeAccountID` has been explicitly set.
  var hasNodeAccountID: Bool {return _storage._nodeAccountID != nil}
  /// Clears the value of `nodeAccountID`. Subsequent reads from it will return its default value.
  mutating func clearNodeAccountID() {_uniqueStorage()._nodeAccountID = nil}

  /// the fee the client pays, which is split between the network and the node
  var transactionFee: UInt64 {
    get {return _storage._transactionFee}
    set {_uniqueStorage()._transactionFee = newValue}
  }

  ///the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration
  var transactionValidDuration: Proto_Duration {
    get {return _storage._transactionValidDuration ?? Proto_Duration()}
    set {_uniqueStorage()._transactionValidDuration = newValue}
  }
  /// Returns true if `transactionValidDuration` has been explicitly set.
  var hasTransactionValidDuration: Bool {return _storage._transactionValidDuration != nil}
  /// Clears the value of `transactionValidDuration`. Subsequent reads from it will return its default value.
  mutating func clearTransactionValidDuration() {_uniqueStorage()._transactionValidDuration = nil}

  /// should a record of this transaction be generated? (A receipt is always generated, but the record is optional)
  var generateRecord: Bool {
    get {return _storage._generateRecord}
    set {_uniqueStorage()._generateRecord = newValue}
  }

  /// any notes or descriptions that should be put into the record (max length 100)
  var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// Hedera multisig admin deletes a file or smart contract
  var adminDelete: Proto_AdminDeleteTransactionBody {
    get {
      if case .adminDelete(let v)? = _storage._data {return v}
      return Proto_AdminDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .adminDelete(newValue)}
  }

  ///to undelete an entity deleted by AdminDelete
  var adminUndelete: Proto_AdminUndeleteTransactionBody {
    get {
      if case .adminUndelete(let v)? = _storage._data {return v}
      return Proto_AdminUndeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .adminUndelete(newValue)}
  }

  /// call a function of a contract instance
  var contractCall: Proto_ContractCallTransactionBody {
    get {
      if case .contractCall(let v)? = _storage._data {return v}
      return Proto_ContractCallTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCall(newValue)}
  }

  /// create a contract instance
  var contractCreateInstance: Proto_ContractCreateTransactionBody {
    get {
      if case .contractCreateInstance(let v)? = _storage._data {return v}
      return Proto_ContractCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCreateInstance(newValue)}
  }

  /// modify info such as expiration date for a contract instance
  var contractUpdateInstance: Proto_ContractUpdateTransactionBody {
    get {
      if case .contractUpdateInstance(let v)? = _storage._data {return v}
      return Proto_ContractUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractUpdateInstance(newValue)}
  }

  /// attach a new claim to an account
  var cryptoAddClaim: Proto_CryptoAddClaimTransactionBody {
    get {
      if case .cryptoAddClaim(let v)? = _storage._data {return v}
      return Proto_CryptoAddClaimTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoAddClaim(newValue)}
  }

  /// create a new cryptocurrency account
  var cryptoCreateAccount: Proto_CryptoCreateTransactionBody {
    get {
      if case .cryptoCreateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoCreateAccount(newValue)}
  }

  /// delete a cryptocurrency account (mark as deleted, and transfer hbars out)
  var cryptoDelete: Proto_CryptoDeleteTransactionBody {
    get {
      if case .cryptoDelete(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDelete(newValue)}
  }

  /// remove a claim from an account
  var cryptoDeleteClaim: Proto_CryptoDeleteClaimTransactionBody {
    get {
      if case .cryptoDeleteClaim(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteClaimTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDeleteClaim(newValue)}
  }

  /// transfer hbars between accounts
  var cryptoTransfer: Proto_CryptoTransferTransactionBody {
    get {
      if case .cryptoTransfer(let v)? = _storage._data {return v}
      return Proto_CryptoTransferTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoTransfer(newValue)}
  }

  /// modify information such as the expiration date for an account
  var cryptoUpdateAccount: Proto_CryptoUpdateTransactionBody {
    get {
      if case .cryptoUpdateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoUpdateAccount(newValue)}
  }

  /// add bytes to the end of the contents of a file
  var fileAppend: Proto_FileAppendTransactionBody {
    get {
      if case .fileAppend(let v)? = _storage._data {return v}
      return Proto_FileAppendTransactionBody()
    }
    set {_uniqueStorage()._data = .fileAppend(newValue)}
  }

  /// create a new file
  var fileCreate: Proto_FileCreateTransactionBody {
    get {
      if case .fileCreate(let v)? = _storage._data {return v}
      return Proto_FileCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileCreate(newValue)}
  }

  /// delete a file (remove contents and mark as deleted until it expires)
  var fileDelete: Proto_FileDeleteTransactionBody {
    get {
      if case .fileDelete(let v)? = _storage._data {return v}
      return Proto_FileDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .fileDelete(newValue)}
  }

  /// modify information such as the expiration date for a file
  var fileUpdate: Proto_FileUpdateTransactionBody {
    get {
      if case .fileUpdate(let v)? = _storage._data {return v}
      return Proto_FileUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileUpdate(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    /// Hedera multisig admin deletes a file or smart contract
    case adminDelete(Proto_AdminDeleteTransactionBody)
    ///to undelete an entity deleted by AdminDelete
    case adminUndelete(Proto_AdminUndeleteTransactionBody)
    /// call a function of a contract instance
    case contractCall(Proto_ContractCallTransactionBody)
    /// create a contract instance
    case contractCreateInstance(Proto_ContractCreateTransactionBody)
    /// modify info such as expiration date for a contract instance
    case contractUpdateInstance(Proto_ContractUpdateTransactionBody)
    /// attach a new claim to an account
    case cryptoAddClaim(Proto_CryptoAddClaimTransactionBody)
    /// create a new cryptocurrency account
    case cryptoCreateAccount(Proto_CryptoCreateTransactionBody)
    /// delete a cryptocurrency account (mark as deleted, and transfer hbars out)
    case cryptoDelete(Proto_CryptoDeleteTransactionBody)
    /// remove a claim from an account
    case cryptoDeleteClaim(Proto_CryptoDeleteClaimTransactionBody)
    /// transfer hbars between accounts
    case cryptoTransfer(Proto_CryptoTransferTransactionBody)
    /// modify information such as the expiration date for an account
    case cryptoUpdateAccount(Proto_CryptoUpdateTransactionBody)
    /// add bytes to the end of the contents of a file
    case fileAppend(Proto_FileAppendTransactionBody)
    /// create a new file
    case fileCreate(Proto_FileCreateTransactionBody)
    /// delete a file (remove contents and mark as deleted until it expires)
    case fileDelete(Proto_FileDeleteTransactionBody)
    /// modify information such as the expiration date for a file
    case fileUpdate(Proto_FileUpdateTransactionBody)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_TransactionBody.OneOf_Data, rhs: Proto_TransactionBody.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.adminDelete(let l), .adminDelete(let r)): return l == r
      case (.adminUndelete(let l), .adminUndelete(let r)): return l == r
      case (.contractCall(let l), .contractCall(let r)): return l == r
      case (.contractCreateInstance(let l), .contractCreateInstance(let r)): return l == r
      case (.contractUpdateInstance(let l), .contractUpdateInstance(let r)): return l == r
      case (.cryptoAddClaim(let l), .cryptoAddClaim(let r)): return l == r
      case (.cryptoCreateAccount(let l), .cryptoCreateAccount(let r)): return l == r
      case (.cryptoDelete(let l), .cryptoDelete(let r)): return l == r
      case (.cryptoDeleteClaim(let l), .cryptoDeleteClaim(let r)): return l == r
      case (.cryptoTransfer(let l), .cryptoTransfer(let r)): return l == r
      case (.cryptoUpdateAccount(let l), .cryptoUpdateAccount(let r)): return l == r
      case (.fileAppend(let l), .fileAppend(let r)): return l == r
      case (.fileCreate(let l), .fileCreate(let r)): return l == r
      case (.fileDelete(let l), .fileDelete(let r)): return l == r
      case (.fileUpdate(let l), .fileUpdate(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  
struct Proto_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the body of the transaction, which needs to be signed
  var body: Proto_TransactionBody {
    get {return _storage._body ?? Proto_TransactionBody()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  /// the signatures on the body, to authorize the transaction
  var sigs: Proto_SignatureList {
    get {return _storage._sigs ?? Proto_SignatureList()}
    set {_uniqueStorage()._sigs = newValue}
  }
  /// Returns true if `sigs` has been explicitly set.
  var hasSigs: Bool {return _storage._sigs != nil}
  /// Clears the value of `sigs`. Subsequent reads from it will return its default value.
  mutating func clearSigs() {_uniqueStorage()._sigs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_TransactionBody) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".TransactionBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionID"),
    2: .same(proto: "nodeAccountID"),
    3: .same(proto: "transactionFee"),
    4: .same(proto: "transactionValidDuration"),
    5: .same(proto: "generateRecord"),
    6: .same(proto: "memo"),
    20: .same(proto: "adminDelete"),
    21: .same(proto: "adminUndelete"),
    7: .same(proto: "contractCall"),
    8: .same(proto: "contractCreateInstance"),
    9: .same(proto: "contractUpdateInstance"),
    10: .same(proto: "cryptoAddClaim"),
    11: .same(proto: "cryptoCreateAccount"),
    12: .same(proto: "cryptoDelete"),
    13: .same(proto: "cryptoDeleteClaim"),
    14: .same(proto: "cryptoTransfer"),
    15: .same(proto: "cryptoUpdateAccount"),
    16: .same(proto: "fileAppend"),
    17: .same(proto: "fileCreate"),
    18: .same(proto: "fileDelete"),
    19: .same(proto: "fileUpdate"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: Proto_TransactionID? = nil
    var _nodeAccountID: Proto_AccountID? = nil
    var _transactionFee: UInt64 = 0
    var _transactionValidDuration: Proto_Duration? = nil
    var _generateRecord: Bool = false
    var _memo: String = String()
    var _data: Proto_TransactionBody.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _nodeAccountID = source._nodeAccountID
      _transactionFee = source._transactionFee
      _transactionValidDuration = source._transactionValidDuration
      _generateRecord = source._generateRecord
      _memo = source._memo
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transactionID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._nodeAccountID)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._transactionFee)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._transactionValidDuration)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._generateRecord)
        case 6: try decoder.decodeSingularStringField(value: &_storage._memo)
        case 7:
          var v: Proto_ContractCallTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .contractCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .contractCall(v)}
        case 8:
          var v: Proto_ContractCreateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .contractCreateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .contractCreateInstance(v)}
        case 9:
          var v: Proto_ContractUpdateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .contractUpdateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .contractUpdateInstance(v)}
        case 10:
          var v: Proto_CryptoAddClaimTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoAddClaim(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoAddClaim(v)}
        case 11:
          var v: Proto_CryptoCreateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoCreateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoCreateAccount(v)}
        case 12:
          var v: Proto_CryptoDeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoDelete(v)}
        case 13:
          var v: Proto_CryptoDeleteClaimTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoDeleteClaim(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoDeleteClaim(v)}
        case 14:
          var v: Proto_CryptoTransferTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoTransfer(v)}
        case 15:
          var v: Proto_CryptoUpdateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoUpdateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoUpdateAccount(v)}
        case 16:
          var v: Proto_FileAppendTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileAppend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileAppend(v)}
        case 17:
          var v: Proto_FileCreateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileCreate(v)}
        case 18:
          var v: Proto_FileDeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileDelete(v)}
        case 19:
          var v: Proto_FileUpdateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileUpdate(v)}
        case 20:
          var v: Proto_AdminDeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .adminDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .adminDelete(v)}
        case 21:
          var v: Proto_AdminUndeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .adminUndelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .adminUndelete(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transactionID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._nodeAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._transactionFee != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._transactionFee, fieldNumber: 3)
      }
      if let v = _storage._transactionValidDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._generateRecord != false {
        try visitor.visitSingularBoolField(value: _storage._generateRecord, fieldNumber: 5)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 6)
      }
      switch _storage._data {
      case .contractCall(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .contractCreateInstance(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .contractUpdateInstance(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .cryptoAddClaim(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .cryptoCreateAccount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .cryptoDelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .cryptoDeleteClaim(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .cryptoTransfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .cryptoUpdateAccount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .fileAppend(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .fileCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .fileDelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .fileUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .adminDelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .adminUndelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TransactionBody, rhs: Proto_TransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._nodeAccountID != rhs_storage._nodeAccountID {return false}
        if _storage._transactionFee != rhs_storage._transactionFee {return false}
        if _storage._transactionValidDuration != rhs_storage._transactionValidDuration {return false}
        if _storage._generateRecord != rhs_storage._generateRecord {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    func _protobuf_generated_isEqualTo(other: Proto_Transaction) -> Bool {
        return false
    }
    
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "sigs"),
  ]

  fileprivate class _StorageClass {
    var _body: Proto_TransactionBody? = nil
    var _sigs: Proto_SignatureList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
      _sigs = source._sigs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._body)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sigs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._sigs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Transaction, rhs: Proto_Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        if _storage._sigs != rhs_storage._sigs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
