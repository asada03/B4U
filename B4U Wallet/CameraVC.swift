//
//  CameraVC.swift
//  B4U Wallet
//
//  Created by Andres Luis Sada Govela on 14/02/18.
//  Copyright Â© 2018 Andres Luis Sada Govela. All rights reserved.
//

import UIKit
import Photos

protocol AddImagesProtocol {
    func addImage(_ image: UIImage)
}

class CameraVC: UIViewController {
    
    @IBOutlet fileprivate var captureButton: UIButton!
    
    ///Displays a preview of the video output generated by the device's cameras.
    @IBOutlet fileprivate var capturePreviewView: UIView!
    
    ///Allows the user to put the camera in photo mode.
    @IBOutlet fileprivate var toggleCameraButton: UIButton!
    @IBOutlet fileprivate var toggleFlashButton: UIButton!
    
    var delegate: AddImagesProtocol!
    
    let cameraController = CameraController()
    
    override var prefersStatusBarHidden: Bool { return true }
    
    override func viewDidLoad() {
        super.viewDidLoad()

        cameraController.prepare {(error) in
            if let error = error {
                print(error)
            }
            
            try? self.cameraController.displayPreview(on: self.capturePreviewView)
        }
        
        captureButton.layer.borderColor = UIColor.black.cgColor
        captureButton.layer.borderWidth = 2
        
        captureButton.layer.cornerRadius = min(captureButton.frame.width, captureButton.frame.height) / 2
        
//        NotificationCenter.default.addObserver(self, selector: #selector(self.rotated), name: NSNotification.Name.UIDeviceOrientationDidChange, object: nil)
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        self.navigationController?.setNavigationBarHidden(true, animated: animated)
    }
    
    private func updatePreviewLayer(layer: AVCaptureConnection, orientation: AVCaptureVideoOrientation) {
        
        layer.videoOrientation = orientation
        
        if cameraController.previewLayer != nil {
            cameraController.previewLayer!.frame = self.view.bounds
            cameraController.rotatedToOrientation(orientation)
        }
        
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        
        if let connection =  cameraController.previewLayer?.connection  {
            
            let currentDevice: UIDevice = UIDevice.current
            
            let orientation: UIDeviceOrientation = currentDevice.orientation
            
            let previewLayerConnection : AVCaptureConnection = connection
            
            if previewLayerConnection.isVideoOrientationSupported {
                
                switch (orientation) {
                case .portrait:
                    updatePreviewLayer(layer: previewLayerConnection, orientation: .portrait)
                    
                case .landscapeRight:
                    updatePreviewLayer(layer: previewLayerConnection, orientation: .landscapeLeft)
                    
                case .landscapeLeft:
                    updatePreviewLayer(layer: previewLayerConnection, orientation: .landscapeRight)
                    
                case .portraitUpsideDown:
                    updatePreviewLayer(layer: previewLayerConnection, orientation: .portraitUpsideDown)
                    
                default:
                    updatePreviewLayer(layer: previewLayerConnection, orientation: .portrait)
                }
            }
        }
    }
    
//    private func fixOrientation(_ img: UIImage) -> UIImage {
//        if !UIDevice.current.orientation.isLandscape {
//            return img
//        }
//
//        UIGraphicsBeginImageContextWithOptions(img.size, false, img.scale)
//        let rect = CGRect(x: 0, y: 0, width: img.size.width, height: img.size.height)
//        img.draw(in: rect)
//
//        let normalizedImage = UIGraphicsGetImageFromCurrentImageContext()!
//        UIGraphicsEndImageContext()
//
//        return img.imageRotatedByDegrees(90.0)
//    }


    // MARK: Actions
    @IBAction func toggleFlash(_ sender: UIButton) {
        if cameraController.flashMode == .on {
            cameraController.flashMode = .off
            toggleFlashButton.setImage(#imageLiteral(resourceName: "Flash Off Icon"), for: .normal)
        }
            
        else {
            cameraController.flashMode = .on
            toggleFlashButton.setImage(#imageLiteral(resourceName: "Flash On Icon"), for: .normal)
        }
    }
    
    @IBAction func switchCameras(_ sender: UIButton) {
        do {
            try cameraController.switchCameras()
        }
            
        catch {
            print(error)
        }
        
        switch cameraController.currentCameraPosition {
        case .some(.front):
            toggleCameraButton.setImage(#imageLiteral(resourceName: "Front Camera Icon"), for: .normal)
            
        case .some(.rear):
            toggleCameraButton.setImage(#imageLiteral(resourceName: "Rear Camera Icon"), for: .normal)
            
        case .none:
            return
        }
    }
    
    private func removeRotationForImage(_ image: UIImage) -> UIImage {
        if image.imageOrientation == .up {
            return image
        }
        
        var orientation = UIImageOrientation.right
        
        switch UIDevice.current.orientation {
        case .landscapeRight:
            orientation = .right
            
        case  .landscapeLeft:
            orientation = .left
            
        case  .portrait:
            orientation = .up
            
        case .portraitUpsideDown:
            orientation = .down
            
        default:
            orientation = .up
        }
        
        UIGraphicsBeginImageContextWithOptions(image.size, false, image.scale)
        image.draw(in: CGRect(origin: CGPoint(x: 0, y: 0), size: image.size))
        let normalizedImage: UIImage = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        return UIImage(cgImage: normalizedImage.cgImage!, scale: 1.0, orientation: orientation)
    }
    
    @IBAction func captureImage(_ sender: UIButton) {
        cameraController.captureImage {(image, error) in
            guard let image = image else {
                print(error ?? "Image capture error")
                return
            }
            
            if self.delegate != nil {
                print ("set image orientation:\(image.imageOrientation)")
                
                self.delegate.addImage(self.removeRotationForImage(image)) //.rotate(byDegrees: 90.0))
            }
            
//            try? PHPhotoLibrary.shared().performChangesAndWait {
//                PHAssetChangeRequest.creationRequestForAsset(from: image)
//            }
        }
    }
    @IBAction func backButtonPressed(_ sender: UIButton) {
        navigationController!.popViewController(animated: true)
    }
}


extension UIImage {
//    func image(withRotation radians: CGFloat) -> UIImage {
//        image.trans
//    }
    func image(withRotation radians: CGFloat) -> UIImage {
        let cgImage = self.cgImage!
        let LARGEST_SIZE = CGFloat(max(self.size.width, self.size.height))
        let context = CGContext.init(data: nil, width:Int(LARGEST_SIZE), height:Int(LARGEST_SIZE), bitsPerComponent: cgImage.bitsPerComponent, bytesPerRow: 0, space: cgImage.colorSpace!, bitmapInfo: cgImage.bitmapInfo.rawValue)!
        
        var drawRect = CGRect.zero
        drawRect.size = self.size
        let drawOrigin = CGPoint(x: (LARGEST_SIZE - self.size.width) * 0.5,y: (LARGEST_SIZE - self.size.height) * 0.5)
        drawRect.origin = drawOrigin
        var tf = CGAffineTransform.identity
        tf = tf.translatedBy(x: LARGEST_SIZE * 0.5, y: LARGEST_SIZE * 0.5)
        tf = tf.rotated(by: CGFloat(radians))
        tf = tf.translatedBy(x: LARGEST_SIZE * -0.5, y: LARGEST_SIZE * -0.5)
        context.concatenate(tf)
        context.draw(cgImage, in: drawRect)
        var rotatedImage = context.makeImage()!
        
        drawRect = drawRect.applying(tf)
        
        rotatedImage = rotatedImage.cropping(to: drawRect)!
        let resultImage = UIImage(cgImage: rotatedImage)
        return resultImage
        
        
    }
}

//extension UIImage {
//
//
//
//    func rotate(_ rotation: Int) -> UIImage {
//        let degree = Float(90 * rotation)
//        let radians = CGFloat(degree * Float.pi / 180.0)
//        let rotatedSize = self.size
//        let scale = UIScreen.main.scale
//        UIGraphicsBeginImageContextWithOptions(rotatedSize, false, scale)
//        if let bitmap = UIGraphicsGetCurrentContext() {
//            bitmap.translateBy(x: rotatedSize.width / 2, y:rotatedSize.height / 2)
//            bitmap.rotate(by: radians)
//            bitmap.scaleBy(x: 1.0, y: -1.0)
//            bitmap.draw(self.cgImage!, in:CGRect(origin: CGPoint(x: -self.size.height / 2,y :-self.size.width / 2), size: CGSize(width: self.size.height, height: self.size.width)))
//            if let newImage = UIGraphicsGetImageFromCurrentImageContext(){
//                return newImage
//            }
//        }
//
//        return self
//    }
//}

